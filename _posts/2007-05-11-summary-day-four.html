---
layout: post
name: summary-day-four
layout: post
title: JavaOne 2007 Summary - Day Four
date: 2007-05-11 22:37:00 +10:00
background: /img/bg-old-post.jpg
---
Here's a list of the sessions I attended on the final day:<br /><br /><ul><li><a href="http://www28.cplan.com/sb158/session_details.jsp?isid=285746&amp;amp;ilocation_id=158-1&amp;amp;ilanguage=english" target="_blank">TS-4746</a> - Hibernate Search: Googling Your Java Technology-Based Persistent Domain Model</li><li><a href="http://www28.cplan.com/sb158/session_details.jsp?isid=285911&amp;amp;ilocation_id=158-1&amp;amp;ilanguage=english" target="_blank">TS-1911</a> - Event-Driven Application Servers</li><li><a href="http://www28.cplan.com/sb158/session_details.jsp?isid=286721&amp;ilocation_id=158-1&amp;ilanguage=english" target="_blank">TS-4721</a> - Implementing Java EE Applications, Using Enterprise JavaBeans (EJB) 3 Technology: Real-World Tips, Tricks, and New Design Patterns</li><li><a href="http://www28.cplan.com/sb158/session_details.jsp?isid=286112&amp;ilocation_id=158-1&amp;ilanguage=english" target="_blank">TS-4112</a> - Declarative Programming: Tighten Enterprise JavaBeans (EJB) 3.0 and JSR 303 Beans Validation</li></ul><strong>TS-4746 - Hibernate Search: Googling Your Java Technology-Based Persistent Domain Model</strong><br /><em>Emmanuel Bernard, JBoss</em><br />So this was an introduction and demo of the new Hibernate project which integrates <a href="http://hibernate.org" target="_blank">Hibernate</a> and <a href="http://lucene.apache.org" target="_blank">Apache Lucene</a> called <a href="http://search.hibernate.org" target="_blank">Hibernate Search</a>. So the main use-case for this technology is that full-text database search sucks and is very database dependent. So using annotations on your domain model Hibernate maintains a Lucene index of the annotated fields. So when you add, update or delete an object the using Hibernate the index get updated. So you query the index Hibernate Search provides and extension to the Hibernate Query API which allows you to create standard Lucene queries then wrap them and pass them to Hibernate. So when you execute a query what you get back is Hibernate managed objects. This is very powerful because to can build very complex Lucene queries using things like proximity, ranking and result weighting and what you get back from your search is your domain objects. The demo that Emmanuel showed was replacing the search function in the Seam DVD store with a Hibernate search based one which greatly improved the results being returned by the search. Currently Hibernate search only works with Hibernate and the Hibernate JPA implementation but the goal is to make Hibernate Search work with any JPA provider. I can see many other use cases for this technology and have been experimenting with Lucene for building scalable database indexing and searching.<br /><br /><br /><br /><strong>TS-1911 - Event-Driven Application Servers</strong><br /><em>Alexandre Vasseur, (Independent); Thomas Bernhardt, Esper Open Source Project</em><br />I had heard a bit about Event Driven App Servers in the past and had always thought they really only served a need for a specific niche market. But after this session which looked at a specific open source event driven app server called Esper (<a href="http://esper.codehaus.org/" target="_blank">http://esper.codehaus.org/</a>) I can see that maybe this technology is ready for the main stream especially in the domain of BAM (Business Activity Monitoring). The Esper architecture is quite impressive but I'm not to sure about the SQL like query language. I think this is an area where a DSL (Domain Specific Language) might be a better choice. Well I guess what they have is a DSL but what I think about would be to provide a framework for creating DSLs for Esper that more closely map to the domain your are working in. I guess the coolest feature of this kind of technology is being able to easily infer temporal information from event streams. This is one project to keep an eye on!<br /><br /><br /><br /><br /><strong>TS-4721 - Implementing Java EE Applications, Using Enterprise JavaBeans (EJB) 3 Technology: Real-World Tips, Tricks, and New Design Patterns</strong><br /><em>Fabiane Nardon, Zilics; Edgar A Silva, JBoss, a division of Red Hat</em><br />I have been working with EJB3 and JEE5 technology for a while now so most of the patterns that were outlined were nothing terrible new. It's good to see that at least some people around the world are thinking about how we can apply different patterns to EJB3 rather than just keep doing the same old crappy patterns we were forced to use due to the limitations with previous EJB spec. This is especially true for anyone who used CMP entity beans in anger. Now that we can remove the Entity bean to Value Object layer (well in most cases) and simply use our EJB3 Entity classes as value objects I think some work in coming up with some best practice patterns (So not just the DAO pattern) needs to happen. When talking about EJB3 many people neglect the fact the many organization have a hell of a lot of legacy EJB2 and even EJB1 code that they will need to support moving forward. There will be very few organizations willing to do a complete re-write of there old code to EJB3. Now EJB3 can coexists with older EJB code and they can even interoperate to some extent. What's needed is a series of patterns,  best practice and tools support to allow developers to refactor old EJB code into EJB3 but have it continue to function within other legacy code but also not limit the usage scope for new EJB3 code. Session Beans would be pretty straight forward but CMP entity beans are another story. I'm working on another blog post currently to highlight some more of the EJB2 to EJB3 migration issues as well as outline strategies to help deal with them so stay tuned.<br /><br /><br /><br /><br /><strong>TS-4112 - Declarative Programming: Tighten Enterprise JavaBeans (EJB) 3.0 and JSR 303 Beans Validation</strong><br /><em>Emmanuel Bernard, JBoss</em><br />Emmanuel was very busy today. One big highlight of this session was the need for the adoption of this standard by other specs both in the JEE and JSE worlds. I totally agree with this as it then gives you the ability to add validation at a single point in your application and have is used by every tier. This means that my view tier could easily provide visible feedback to the user and at the data tier the same validation could be added to my database as a constraint. Currently Hibernate provides a validation framework that integrates with the Hibernate core and JPA implementation as well as JBoss Seam which gives you end to end validation using simple annotations on your domain model. This spec is still really in it's early days but the work done my the Hibernate team already goes a long way and is a going starting point for this spec. In the mean time just use the Hibernate Validations libraries as I'm sure when the spec comes out it won't be to hard to refactor. Man the Hibernate guys have been cranking out new stuff over the past couple of months and that's without the <a href="http://www.hibernate.org/414.html" target="_blank">Shards</a> project which was donated by Google. Keep up the good work!!!!!<br /><br /><br />I'm planning to post a complete JavaOne summary when I get back home....I had a great time at my first JavaOne but I think my brain is melting :) maybe it was just all the beer I drank this week.<br /><br />